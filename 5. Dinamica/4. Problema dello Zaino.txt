-----------------------------------------------------------------------------------Definizione del problema

Input: n oggetti di peso Wi>0 e valora Vi>0. Limite W di peso inseribile nello zaino.

Obbiettivo: Selezionare un sottoinsieme S degli n oggetti in modo che la somma dei loro pesi non superi W e
che il valore totale sia massimo.

Il problema corrisponde al Subset Sums, quando Vi=Wi.

-----------------------------------------------------------------------------------------Strategie Greedy

Strategia 1: Inserire prima gli oggetti con valore più grande.

Strategia 2: Inserire prima gli oggetti più leggeri.

Strategia 3: Inserire prima gli oggetti con rapporto Vi/Wi più grande.

Nessuna di queste strategie è in grado di risolvere il problema dello zaino, che per l'appunto non è 
risolvibile con una Strategia Greedy. (Basta trovare un controesempio).

------------------------------------------------------------------------------------------------Definizioni

OPT(i,w): Valore della soluzione ottima per gli oggetti {1,...,i} con peso totale W.
    Caso 1: La soluzione ottima per i primi i oggetti, con limite di utilizzo w non include il oggetti i. 
    In questo caso la soluzione ottima è OPT(i,w)=OPT(i-1,w).

    Caso 2: La soluzione ottima per i primi i oggetti, con limite di utilizzo w include il oggetti i. 
    In questo caso la soluzione ottima è OPT(i,w)=Wi+OPT(i-1,W-Wi).

La soluzione ottima per i primi i oggetti con limite di utilizzo W va ricercata tra le soluzioni ottime per i 
due casi. Questo però se i>0 e Wi<=W.

Se i=0 banalmente si ha OPT(i,w)=0. Se Wi>W è possibile solo il caso 1 perchè il oggetti i non può far 
parte della soluzione in quanto richiede più tempo di quello a disposizione.

       |0                                 se i=0
       |
OPT(J)=|OPT(i-1,w)                        se Wi>W  
       |
       |max{OPT(i-1,w), Wi+OPT(i-1,W-Wi)} Altrimenti


-----------------------------------------------------------------------------------------------Pseudocodice

#Algoritmo che computa la soluzione ottima per il problema dello zaino
ProbZain(){n,w1,...,Wn,V1,...,Vn,W}{
    for(w=0 to W){
        M[0,w]=0
    }

    for(i=1 to n){
        for(w=o to W){
            if(Wi>W){
                M[i,w]=M[i-1,W]
            }else{
                M[i,w]=max{M[i-1,w],Vi+M[i-1,w-wi]}
            }
        }
    }
    return M[n,W]
}

Tempo di esecuzione: Theta(n W)
Per W con un valore ragionevolmente piccolo.

-------------------------------------------------------------------------------------------------------Extra

Esercizio: Scrivere lo pseudocodice dell’algoritmo che produce la soluzione ottima per un’istanza del 
problema dello zaino.

Esercizio: Scrivere la versione ricorsiva dell’algoritmo di programmazione dinamica per il problema dello 
zaino.

------------------------------------------------------------------------------------------------------------