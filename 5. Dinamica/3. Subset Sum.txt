-----------------------------------------------------------------------------------Definizione del problema

Input: Un insieme di n job 1,2,...,n e un tempo Wi>0 associato ad ogni job. Un limite W al tempo per il
quale il processore può essere utilizzato.

Obbiettivo: selezionare un sottoinsieme S degli n job t.c. la sommatoria dei tempi di esecuzione si quanto
più grande possibile ma comunque minore uguale di W.

Possibili soluzioeni Greedy:
    Greedy 1: ad ogni passo inserisce in S il job con peso piu` alto in modo che la durata complessiva dei 
    job in S non superi W.
    Esempio: Input una volta ordinato [W/2+1,W/2,W/2]. L’algoritmo greedy seleziona solo il primo mentre 
    la soluzione ottima e` formata dagli ultimi due.

    Greedy 2: ad ogni passo inserisce in S il job con peso piu` basso in modo che la duranta complessiva 
    dei job in S non superi W.
    Esempio: Input [1,W/2,W/2] una volta ordinato . L’algoritmo greedy seleziona i primi due per un peso 
    complessivo di 1+W/2. mentre la soluzione ottima e` formata dagli ultimi due di peso complessivo W.


------------------------------------------------------------------------------------------------Definizioni

OPT(i,w): Valore della soluzione ottima per i job {1,...,i} con limite W sul tempo di utilizzo del processore.
    Caso 1: La soluzione ottima per i primi i job, con limite di utilizzo w non include il job i. In questo
    caso la soluzione ottima è OPT(i,w)=OPT(i-1,w).

    Caso 2: La soluzione ottima per i primi i job, con limite di utilizzo w include il job i. In questo caso
    la soluzione ottima è OPT(i,w)=Wi+OPT(i-1,W-Wi).

La soluzione ottima per i primi i job con limite di utilizzo W va ricercata tra le soluzioni ottime per i 
due casi. Questo però se i>0 e Wi<=W.

Se i=0 banalmente si ha OPT(i,w)=0. Se Wi>W è possibile solo il caso 1 perchè il job i non può far parte
della soluzione in quanto richiede più tempo di quello a disposizione.

       |0                                 se i=0
       |
OPT(J)=|OPT(i-1,w)                        se Wi>W  
       |
       |max{OPT(i-1,w), Wi+OPT(i-1,W-Wi)} Altrimenti

-----------------------------------------------------------------------------------------------Pseudocodice

#Algoritmo per il calcolo della soluzione al problema del SS: Si riempie un array bodimensionale NxW a partire
dalle locazioni di indice di riga i più piccolo.
SS(n,W1,...,Wn,W){
    for(w=0 to W){
        M[0,w]=0
    }

    for(i=1 to n){
        for(w=0 to W){
            if(Wi>w){
                M[i,w]=M[i-1,w]
            }else{
                M[i,w]=max{M[i-1,w],Wi+M[i-1,W-Wi]}
            }
        }
    }
    return M{n,W}
}

Analisi: Non è polinomiale nella dimensione dell'input: L'algoritmo è efficiente quando W ha un valore 
ragionevolmente piccolo. Tempo: Theta(n W)

#Algoritmo ricorsivo per il calcolo del SS:
for (i=0 to n){
    for (w=0 to W){
        M[i,w]=empty
    }
}

SS(i,w){
    if (i=0){
        M[i,w]=0
    }
    if (M[i,w] ≠ empty){
        return M[i,w]
    }
    if (wi > w){
        M[i,w]=SS(i-1,w)
    }else{
        M[i,w]= max{SubsetSums(i-1,w), wi+ SubsetSums(i-1, w-wi)
    }
    return M[i,w]
}

#Algoritmo ricorsivo che stampa la soluzioen di SS:
Invochiamo SS

FindSubset(i,w){
    if(i=0){
        return null
    }
    if (M[i,w]=M[i-1,w]){
        FindSubset(i-1,w)
    }else{
        print i
        FindSubset(i-1,w-wi)
    }
}
Analisi: Tempo O(n)

-----------------------------------------------------------------------------------------------------------