
-------------------------------------------------------------------- Definizione del problema

Input: un array a non ordinato con un inizio sx e una fine dx.

Obbiettivo: Vogliamo ordinare l'array a.

Funzionamento:
  * Decomposizione: se la sequenza ha almeno due elementi, scegli un elemento pivot e dividi la sequenza in
                    due sotto-sequenza in modo tale che la prima contenga elementi minori o uguali al pivot
                    e la seconda gli elementi maggiori o uguali al pivot.
  * Ricorsione: Ordina ricorsivamente le due sotto-sequenze.
  * Ricombinazione: non occorre fare alcun lavoro di ricombinazione.

-------------------------------------------------------------------- Pseudocodice

QuickSort(a, sx, dx){
    if(sx < dx){
        scegli un pivot p nell'intervallo [sx,...,dx]
        indiceFinalePivot = Distribuzione(a, sx, px, dx)
        QuickSort(a, sx, indiceFinalePivot-1)
        QuickSort(a, indiceFinalePivot+1, dx)
    }
}

-------------------------------------------------------------------- Distribuzione

Funzionamento:
  * Pone il pivot nella posizione a[dx], se già lo è non fa nulla.
  * Usa due indici i e j per scandire il segmento: i parte da s e scorre verso destra, j parte da d - 1 e scorre verso 
    sinistra fino a quando i <= j.
  * Ogni votla che si ha un a[i] > pivot e a[j] < pivot, scambia a[i] con a[j] e poi riprende la scansione.
  * Alla fine della scansione, Distribuzione posiziona il pivot nella posizione corretta.

-------------------------------------------------------------------- Pseudocodice:

Distribuzione(a, sx, px, dx){

    if(a[px] != a[dx])  Scambia(a[p], a[dx]);

    i = sx;
    j = dx - 1;

    while(i <= j){
    
        while((i <= j) && (a[i] <= a[dx])) i = i + 1;
        while((i <= j) && (a[j] >= a[dx])) j = j - 1;
        
        if(i < j){
            Scambia(a[i]), a[j]);
            
            i = i + 1;
            j = j - 1;
        }
        
    }
    if(i != dx) Scambia(a[i], a[dx]);
    return i;
}

Scambia(a[i], a[j]){
    temp = a[j];
    a[j] = a[i];
    a[i] = temp;
}

-------------------------------------------------------------------- Relazione di ricorrenza

La relazione di ricorrenza che esprime il tempo di esecuzione è la seguente:
        | c0               se n<=1 
T(n) <= |
        | T(r-1)+T(n-r)+cn altrimenti
        
NB: r indica il rango del pivot. La sotto-sequenza di sinistra conterrà r-1 elementi, mentre la sottosequenza di destra conterrà n-r elementi.

-------------------------------------------------------------------- Tempo di esecuzione

Distribuzione:  O(n)

QuickSort caso pessimo:     T(n) = O(n^2)

QuickSort caso ottimo:      T(n) = O(nlogn)

QuickSort caso medio:       T(n) = O(nlogn)

QuickSort Tempo Medio di esecuzione: T(n) = O(nlogn)

-------------------------------------------------------------------- Fin
