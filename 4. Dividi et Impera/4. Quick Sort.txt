
-------------------------------------------------------------------- Definizione del problema

Input: un array a non ordinato con un inizio sx e una fine dx.

Obbiettivo: Vogliamo ordinare l'array a.

Funzionamento:
      * Decomposizione: se la sequenza ha almeno due elementi, scegli un elemento pivot e dividi la sequenza in
                        due sotto-sequenza in modo tale che la prima contenga elementi minori o uguali al pivot
                        e la seconda gli elementi maggiori o uguali al pivot.
      * Ricorsione: Ordina ricorsivamente le due sotto-sequenze.
      * Ricombinazione: non occorre fare alcun lavoro di ricombinazione.
                   
-------------------------------------------------------------------- Pseudocodice

QuickSort(a, sx, dx){
    if(sx < dx){
        scegli un pivot p nell'intervallo [sx,...,dx]
        indiceFinalePivot = Distribuzione(a, sx, px, dx)
        QuickSort(a, sx, indiceFinalePivot-1)
        QuickSort(a, indiceFinalePivot+1, dx)
    }
}

-------------------------------------------------------------------- Distribuzione

Algoritmo:
    * Scambia gli elementi a[px] e a[dx], se px è diverso da dx
    * Usa due indici i e j per scandire il segmento: i parte da s e scorre verso destra, j parte da d - 1 e scorre verso 
      sinistra fino a quando i <= j.
    * Ogni votla che si ha un a[i] > pivot e a[j] < pivot, scambia a[i] con a[j] e poi riprende la scansione.
    * Alla fine della scansione, Distribuzione posiziona il pivot nella posizione corretta.
  
Analisi:
    - Dobbiamo stimare il numero di iterazioni eseguite complessivamente dai due while interni.
    1. primo while = numero di confronti tra un elemento a[i] con il pivot
    2. secondo while = numero di confronti tra un elemento a[j] con il pivot
    3. Dopo ogni confronto di a[i] con il pivot:
        3.a viene incrementeato i di 1
        3.b il while esterno termina dopo al più un'interazione
    4. Dopo ogni confronto di a[j] con il pivot:
        4.a viene incrementeato j di 1
        4.b il while esterno termina dopo al più un'interazione
    5. Dopo ogni interazione di ciascuno dei while interni, tranne per l'ultima, 
       viene confrontato un nuovo elemento con il pivot.
    6. Il numero totale di confronti con il pivot è quindi al più n - 2. 
       Il numero di iterazioni complessive dei due while è di n - 2.
    7. Tempo di esecuzione: O(n)


-------------------------------------------------------------------- Pseudocodice:

Distribuzione(a, sx, px, dx):
    if(a[px] != a[dx])  Scambia(a[p], a[dx]);

    i = sx;
    j = dx - 1;

    while(i <= j){
    
        while((i <= j) && (a[i] <= a[dx])) i = i + 1;
        while((i <= j) && (a[j] >= a[dx])) j = j - 1;
        
        if(i < j){
            Scambia(a[i]), a[j]);
            
            i = i + 1;
            j = j - 1;
        }
        
    }
    if(i != dx) Scambia(a[i], a[dx]);
    return i;

Scambia(a[i], a[j]):
    temp = a[j];
    a[j] = a[i];
    a[i] = temp;


-------------------------------------------------------------------- Relazione di ricorrenza

Sia r il rango dell'elemento pivot, la relazione di ricorrenza che esprime il tempo di esecuzione è la seguente:

        | c0                 se n<=1 
T(n) <= |
        | T(r-1)+T(n-r)+cn   altrimenti
        
Analisi:
    - Caso base: se il segmento u cui opera l'algoritmo contiene un solo elemento allora l'algoritmo esegue un
                 numero costante di operazioni per cui il costo è <= c per una certa costance c positiva;
    - Passo ricorsivo: il costo in questo caso è dato dal costo lineare di distribuzione più il costo delle due
                       chiamate ricorsive effettuate: sul segmento composto dagli elementi minori del pivot e 
                       dal segmento composto dagli elementi maggiori del pivot. Il costo in questo caso è al più
                       pari a cn (per una certa costance c > 0) più il costo delle chiamate ricorsive.
        
-------------------------------------------------------------------- Analisi Caso Pessimo

Nel caso pessimo il pivot è tutto a sinistra (r = 1) oppure è tutto a destra (r = n), la relazione diventa:

        T(n) <= T(n - 1) + T(0) + cn <= T(n - 1) + c'n        per un'opportuna costante c';

Applicando iterativamente la relazione di ricorrenza:

        T(n) <= T(n - i) + [Somma per j che va da 0 a (i-1) di] c'(n-j)

Sostituiamo i = n - 1, otteniamo:
        
        T(n) <= T(1) + [Somma per j che va da 0 a (n-2) di] c'(n-j) <= c0 + [Somma per j che va da 0 a (n-1-1) di] c'j <=
                <= c0 + [**] c'(n+1)n/2 - c' = O(n^2)
                
[**]: Compare la sommatoria dei primi n numeri, nell'ultimo passaggio abbiamo un - c' perchè la sommatoria parte da 1
       
-------------------------------------------------------------------- Tempo di esecuzione

QuickSort caso pessimo:     T(n) = O(n^2)

QuickSort caso ottimo:      T(n) = O(nlogn)

QuickSort caso medio:       T(n) = O(nlogn)

QuickSort Tempo Medio di esecuzione: T(n) = O(nlogn)

-------------------------------------------------------------------- Fin
