---------------------------------------------------------------------------------Definizione del problema

Input:
    Grado non direzionato connesso G=(V,E)
    Per ogni arco e, Ce rappresenta il costo dell'arco e.

Obbiettivo: Trovare il minimo spanning tree, ovvero quello con costo totale minimo.

----------------------------------------------------------------------------------------------Definizioni

Albero ricoprente (Spanning Tree): Sia dato un grafo non direzionato conesso G=(V,E). Uno spanning tree 
di G è un sottoinsieme di archi T t.c |T|=n-1 e gli archi di T non formani cicli. In sostanza T forma un
albero che come nodi ha tutti i nodi di G.

Definizione: sia dato un grafo non direzionato connesso G=(V,E) t.c. che ad ogni arco e di G è associato
un costo Ce. Per ogni albero ricoprente T di G, definiamo il costo di T come la sommatoria di tutti i
costi degli archi.

---------------------------------------------------------------------------------------------------Taglio

Taglio: un taglio è una partizione [S,V-S] dell'insieme dei vertici del grafo.

Insieme di archi che attraversano il taglio [S,V-S]: sottoinsieme D di archi che hanno un'estremintà in S
e una di V-S.

------------------------------------------------------------------------------------------------Proprietà

Proprietà del taglio: Sia S un qualsiasi sottoinsieme di nodi e sia e l'arco di costo minimo che 
attraversa [S,V-S]. Ogni minimo albero ricoprente contiene e.

Proprieà del ciclo: Sia C un qualsiasi ciclo e sia f l'arco di costo massimo in C. Nessun minimo albero
ricoprente contiene f.

----------------------------------------------------------------------------------------Algoritmo di Prim

Funzionamento:
  * Ad ogni passo, T è un sottoinsieme di archi dello MST ed S è l'insieme di nodi di T.
  * Inizializzazione: Pone in S un qualsiasi nodo u. Il nodo u sarà la radice dello MST.
  * Ad ogni passo aggiunge a T l'arco (u,v) di costo minimo tra tutti quelli che congiungono un nodo u in
    S ad un nodo v in V-S (Scelta Greedy).
  * Termina quando S=V. (V insieme dei nodi nel grafo)

Implementazione con coda a priorità:
Prim(G,c){

    Sia S l'insieme dei nodi esplorati                                  //Inizializzazione
    Per ogni nodo u non in S, conserva il costo c[u]                    /
    Sia Q la coda a priorità di coppie (c[u],u) t.c. u non è in S       //

    foreach (nodo u in V){
        insert(Q,infinito,u)
    }

    while(Q non è vuota){
        (c[u],u)<--ExtractMin(Q)
        add u to s
        foreach(arco e=(u,v)){
            if ((v non in S)and (Ce<c[v])){
                changeKey(Q,v,Ce)               //Aggiorna il costo del nodo v contenuto nella coda.
            }
        }
    }
}

Analisi: 
O(n^2) con array o lista non ordinati.
O(m log n+n log n) con heap.
Siccome nel problema dello MST il grafo è connesso allora m>=n-1 e O(m log n+n log n)=O(m log n).

-------------------------------------------------------------------------------Modifica algoritmo di Prim

Modifica che restituisce l'insieme dei nodi appartenenti allo MST:
Prim(G,c){

    Sia S l'insieme dei nodi esplorati                                  
    Per ogni nodo u non in S, conserva il costo c[u]                    
    Sia Q la coda a priorità di coppie (c[u],u) t.c. u non è in S
    Sia T l'insieme dei nodi appartenti allo MST       //Prima Modifica

    foreach (nodo u in V){
        insert(Q,infinito,u)
    }

    while(Q non è vuota){
        (c[u],u)<--ExtractMin(Q)
        add u to S
        add u to T                                     //Seconda Modifica
        foreach(arco e=(u,v)){
            if ((v non in S)and (Ce<c[v])){
                changeKey(Q,v,Ce)               
            }
        }
    }
}

-------------------------------------------------------------------------------------Algoritmo di Kruskal

Funzionamento:
  * Considera ciascun arco in ordine non decrescente di peso.
  * Caso 1: Se e crea un ciclo allora scarta e.
  * Caso 2: Se e non crea un ciclo inserisci e in T.

Durante l'esecuzione di Kruskal su G=(V,E), l'insieme di vertici V e l'insieme di archi in T formano una
foresta composta da uno o più alberi, cioè le componenti connesse dal grafo (V,T) sono alberi. (in
pratica si generano dei mini alberi che po si uniranon in uno solo).

Implementazione:
Kruskal(G,c){
    Ordina gli archi in ordine decrescente di peso
    Inizializza T come vuoto

    foreach (nodo u){
        crea un insieme che contine solo u
    }

    for(i=1 to m){                                          //m rappresenta il numero degli archi in G
        (u,v)=ei
        if (u e v sono in due insiemi differenti){
            aggiungi l'arco ei a T
            unisci gli insiemi che contengono u e v
        }
    }
    return T
}

---------------------------------------------------------------------------Implementazione con Union Find

All'interno dell'algoritmo ciascun albero della foresta è rappresentato dal suo insieme di vertici.
Per rappresentare questi vertici, si utilizza la struttura dati Union-Find per la rappresentazione di 
insiemi disgiunti.

Istruzioni supportate dall'Union-Find:
  * MakeUnionFind(S): Crea una collezione di insiemi ognuno dei quali contiene un elemento di S.
       -Viene chiamato nella fase di inizializzazione dell'algoritmo: ciascun insieme creato corrisponde
        ad un albero con un solo vertice.

  * Find(x): Resituisce l'insieme che contiene x.
       -Per ciascun arco esaminato (u,v), l'algoritmo invoca find(u) e find(v). se entrambe le chiamate
        resituiscono lo stesso insieme allora vuol dire che u e v sono nello stesso albero e quindi (u,v)
        crea un ciclo in T.

  * Union(X,Y): unisce gli insieme X e Y.
       -Se l'arco(u,v) non crea un ciclo in T allora l'algoritmo invoca Union(Find(u),Find(v)) per unire
        le componenti connesse di u e v in un'unica componente connessa.

Implementazione con Union-Find:
Kruskal(G,c){
    ordina gli archi in ordine decrescente di peso
    inizializza T come vuoto

    MakeUnionFind(V)

    for(i=1 to m){                                      //m rappresenta il numero degli archi in G                                        
        (u,v)=ei
        if (Find(u)!=Find(v)){
            aggiungi ei a T
            Union(Find(u),Find(v))
        }
    }
    return T
}

Analisi: la fase di inzializzazione prende tempo: O(n) per creare la struttura Union-Find e O(m log m)
per ordinare gli archi. Successicamente per ogni arco esaminato abbiamo tempo O(2m)=O(m) per le due find
e per ogni arco aggiunto O(n) su un totale di n-1 archi che si traduce in (n^2).
Tempo totale: O(m log n)+O(n^2).

-------------------------------------------------Implementazione con Union Find con array e union-by-size

Stessa implementazione della slide precedente ma si usa anche un altro array A per mantenere traccia 
della cardinalità di ciascun insieme. L’array ha n celle perché inizialmente ci sono n insiemi..

Nuovo tempo totale: O(m lon n).

----------------------------------------------------------Implementazione basata su struttura a puntatori

L'insieme viene rappresentato come una struttura a puntatori in modo da semplificare le operazioni di 
unio e find, portando cosi il tempo di esecuzione a O(log n).

---------------------------------------------------------------------------------------------------------