---------------------------------------------------------------------------------------------Definizioni

Visita in profondità: l'algoritmo parte da un nodo s e per un arco(s,u) si spinge ricorsivamente per un
arco(u,x) e cosi via finche non ci sono più archi su. 

Albero DFS: L'algoritmo produce come output un albero, che ha come radice s con un unico lungo ramo di 
figli, che rappresenta il percorso più lungo scandito dall'algoritmo, da cui si diramano altri rami
che rappresentano i backtrack svolti dall'algoritmo.


----------------------------------------------------------------------------------------------------Idea

#Idea
DFS(s){
    expl[s]=True
    R.add(s)
    foreach (arco(s,v) incidente in s)
        if (!expl)
            DFS(v)
        }
    }
}

------------------------------------------------------------------------------------------implementazioni

#Implementazione tramite stack
DFS(s){
    poni expl[s]=true e expl[u]=false per tutti gli altri nodi u            //Tempo O(n)
    stk.push(s)                                                             //Tempo O(1)
    while(stk non vuoto){
        u=stk.pop()                                                         //Tempo ugual al foreach della
        if (esiste un arco(u,v) incidente su u non ancora esaminato){       //BFS
            if (expl[v]=false){
                expl[v]=true
                stk.push(v)
            }
        }
        stk.pop()
    } 
}

Analisi: L'inizializzazione prende tempo costante tranne per quanto riguarda quella dell'array expl[] che
prende come tempo O(n). Per quanto riguarda il While visiterà tutti gli archi del grafo al più due volte
quindi, per tutte le iterazioni del while O(2m).
Totale: O(n)+O(2m)=O(n+2m)=O(n+m).

----------------------------------------------------------------------------------------------------Extra

#Implementazione tramite stack e generazione albero DFS
DFS(s){
    poni expl[s]=true e expl[u]=false per tutti gli altri nodi u
    Inizializza il DFStree come albero vuoto                            //Modifica uno
    stk.push(s)
    while(stk non vuoto){
        u=stk.pop()
        if (esiste un arco(u,v) incidente su u non ancora esaminato){
            if (expl[v]=false){
                expl[v]=true
                DFSTree.add(arco(u,v))                                  //Modifica due
                stk.push(v)
            }
        }
        stk.pop()
    } 
}

--------------------------------------------------------------------------------------------------------
