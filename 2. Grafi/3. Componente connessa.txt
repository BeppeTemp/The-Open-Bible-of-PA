-------------------------------------------------------------------- Definizioni

Componente connessa: 
    - Sottoinsieme di vertici tale per ciascuna coppia di vertici u e v esiste un percorso tra u e v

-------------------------------------------------------------------- Teoremi

Teorema: 
    - Per ogni due nodi s e t di un grafo, le loro componenti connesse o sono uguali o disgiunte.

Dimostrazione: 
    - Banalmente se esiste un percorso tra s e t, ogni nodo u raggiungibile da s è anche raggiungibile
      da t e ogni nodo u raggiungibile da t è raggiungibile da s. Viceversa se non esiste un percorso 
      tra s e t non può esserci un nodo che appartiene sia alla componente connessa di s che a quella di t.

-------------------------------------------------------------------- Pseudocodice

#Algoritmo che trova tutte le componenti connesse in un grafo: il BFS va modificato in modo da lasciare
la fase di inizializzalizzazione di discovered a AllComponents.
AllComponents(g){
    per ogni sono u in g Discovered[u] = false      //Tempo O(n)
    foreach (nodo u in g){
        BFS(u)                                          //Tempo O(n+m)
    }
}

Analisi: Indicando con ni e mi il numero di nodi e di archi dell'iesima compontente connessa il tempo 
necessario per ogni componente conessa sarà di O(ni+mi) quindi il tempo totale sarà dato dalla [somma per i che va da 1 a k di] O(ni+mi), ma siccome le componenti connesse sono a due a due disgiunte questa sommatoria sarà uguale a O(n+m).

Pertanto il tempo totale dell'algorimo è: O(n)+O(n+m) = O(n+m)

-------------------------------------------------------------------- Extra

#Algoritmo che trova le componenti connesse in un grafo, associando i nodi alla componente connessa
di cui fanno parte.

AllCompAss(g){
    per ogni nodo u in g Discovered[u] = false
    inizializza Component[u] = 0 per ogni u in g
    j = 1
    foreach (nodo u in g){
        BFS(u, j)
        j = j + 1
    }
    return Component
}


BFS(u, j){
    inizializza L[0] in modo che contenga solo u                                                    
    Poni il contatore dei livelli i = 0                                                             
    while(i<n-2){                                                                                  
        inizializza L[i+1] come lista vuota                                                             
        foreach (nodo in L[i]){                                                                                            
            foreach (arco(u,v) incidente in u){                                                                
                if (Discovered[v]==false){                                                                     
                    Discovered[v]=true                                                                          
                    Aggiungi v alla lista L[i+1]                                                                        
                    Component[v] = j
                }
            }
        }
        i = i + 1                                                                                    
    }
}

--------------------------------------------------------------------------------------------------------
