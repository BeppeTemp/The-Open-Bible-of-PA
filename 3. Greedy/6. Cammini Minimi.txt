---------------------------------------------------------------------------------Definizione del Problema

Input:
  * Grafo direzionato G=(V,E)
  * Una memoria cache con capacità di memorizzare k elementi.
  * Per ogni arco e, le=valore numerico associato ad e (lunghezza o peso).
  * s=sorgente

Obbiettivo: Trovare i percorsi direzionati più corsto da s verso tutti gli altri nodi.

----------------------------------------------------------------------------------------------Definizioni

Definizione: Per ogni percorso direzionato P. l(P)=somma delle lunghezze degli archi in P (Costo di P).

-------------------------------------------------------------------------------------Varianti del problema

Single Source Shortest Paths: Determinare il cammino minimo da un dato vertice sorgente s ad ogni altro 
vertice.

Single Destination Shortest Paths: Determinare i cammini minimi ad un dato vertice destinazione t da tutti 
gli altri vertici. (può essere ridotta alla prima variante invertendo il costo degli archi).

Single-Pair Shortest Path: Per una data coppia di vertici u e v determinare un cammino minimo da un dato
vertice u a v.

All Pairs Shortest Path: Per ogni coppai di vertici u e v, determinare un cammino minimo da u a v.

---------------------------------------------------------------------------------------------Osservazione

Cicli Negativi: in caso di un ciclo negativo non è possibile definire un percorso minimo.

------------------------------------------------------------------------------------Algoritmo di Dijkstra

Funzionamento:
  * Ad ogni passo mantiene l'insieme S dei nodi esplorati, ovvero quelli per cui è già stata calcolata la
    distanza minima da s.
  * Inizializzo S={s},d(s)=0.
  * Ad ogni passo, seglie tra i nodi non ancora in S ma adiacenti a qualche nodo di S, quello che può 
    essere  raggiunto in modo più economico (scelta greedy).
  * Aggiunge v ad S e pone d(v)=d'(v).
  * d'(v) rappresenta la lunghezza del percorso più corto da s a v tra quelli che passano solo per nodi
    di S.

Psudocodice:
Dijkstra(G,l){
  Sia s l'insieme dei nodi esplorati
  foreach (nodo u in S){
    conservane la distanza d(u)
  }
  inizializza S={s} 
  d(s)=0

  while(S!=V){
    seleziona un nodo che non appartiene a S con almeno un vertice in S per cui
    d'(v)=min(e=(u,v):u appartiene ad s) d(u)+le è il minimo possibile
    aggiungi v a S e definisci d(v)=d'(v)
  }
}

------------------------------------------------------------------------------------Funzionamento a parole

Ogni nodo viene inserito in una cosa contente l'associazione (Distanza da s, nome nodo), all'inzio tutte
le distanze da s sono uguali a infinito. Partendo dal nodo s aggiorno la distanza da s di tutti i nodi 
adiacenti ad s, succesivamente includo il nodo con distanza minore nella lista S e rieseguo l'Algoritmo
sul nodo con distanza da s minima, fino a quando S non contiene tutti i nodi del grafo.

-----------------------------------------------------------------------Implementazione con coda a priorità

Dijkstra(G,s,l){
  sia s settato come nodo esplorato
  per ogni nodo u non in S, conserva la distanza d'(u)
  sia Q una coda a priorità della coppia (d'(u),u) t.c. u non è in S
  per ogni nodo u in S, conserva la distanza d(u)
  insert(Q,(0,s))
  per ogni u diverso da s insert(Q,infinto,u)
  while(S!=V){
    (d(v,v)=extractMin(Q)
    add v to S
    foreach (arco e=(v,z)){
      if (z non in s) and (d(v)+le<d'(z)){
        changeKey(Q,z,d(v)+le)
      }
    }
  }
}
