---------------------------------------------------------------------------------Definizione del Problema

Input: un insieme di job di cui abbiamo la durata dj e il tempo sj in cui il job deve essere terminato 
ovvero la sua scadenza.

Obbiettivo: Trovare uno scheduling di tutti i job che minimizzi il ritardo massimo L=max lj. 

-----------------------------------------------------------------------------------Definizione di ritardo

Ritardo: il ritardo del job j è definito come lj=max{0,fj-sj}, dove fj è il suo tempo di fine dato da,
fj=sj-dj, (ovvero tempo di inizio più durata).

--------------------------------------------------------------------------------Definizione di inversione

Inversione: un'inversione in uno scheduling S è una coppia di job i e j tali che: di<sj ma j viene
eseguito prima di i.

-----------------------------------------------------------------------------------------Strategie Greedy

Strategia 1 (Shortest Processing Time First): Considera prima i job in con tempo di elaborazione dj 
minimo. (due job: uno con tempo di elaborazione pari a 1 e scadenza 100, un altro con tempo di 
elaborazione pari a 10 e scadenza 10, viene eseguito prima il primo e genera ritardi)

#Strategia Migliore
Strategia 2 (Earliest Deadline Time): Considera i job in ordina non decrescente dei tempi entri i quali 
devono essere ultimati.

Strategia 3 (Smallest Slack): Considera prima i job con scarto sj-dj più piccolo. (due job: uno con tempo
di elaborazione pari a 1 e scadenza 2, il secondo con tempo di elaborazione pari a 10 e scadenza 10, viene
prima il job due portando a un)

---------------------------------------------------------------------------------------------Pseudocodice

#Algoritmo che dato in input un instanza del problema minimizzazione dei ritartdi ritorna l'ordine di
esecuzione degli intervalli.

MinRit(){
    ordino gli intervalli in base alla scadenza
    t=0                                             //conta il tempo di inizio del prossimo job

    for(j=1;i<n;j++){
       asegna il job j all'intervallo [t,t+dj]
       sj=t                                         //setta sj del job j
       fj=t+dj                                      //setta fj del job j
       t=t+dj                                       //aggiorna il tempo di inizio del job j+1
    }
    return i nuovi intervalli
}

Analisi:
Tempo ordinamento: O(n log n) (tempo dominante)
Tempo for: O(n)

Tempo totale: O(n)+O(n log n)=O(n log n)

La soluzione cosi proposta gode di due proprietà:
a) Nessun Idle Time, non ci sono momenti in cui la risorsa non viene utilizzata.
b) Nessun Inversione, se un job j ja scadenza maggiore di quella i un job 1 allora viene eseguito i.

---------------------------------------------------------------------------------------------------------

